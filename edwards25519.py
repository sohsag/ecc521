

# This file was *autogenerated* from the file edwards25519.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed = Integer(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed); _sage_const_0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec = Integer(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec); _sage_const_0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3 = Integer(0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3); _sage_const_1 = Integer(1); _sage_const_48 = Integer(48); _sage_const_2 = Integer(2); _sage_const_14 = Integer(14); _sage_const_864 = Integer(864); _sage_const_34 = Integer(34); _sage_const_0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed = Integer(0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed); _sage_const_0x08 = Integer(0x08); _sage_const_5 = Integer(5); _sage_const_12 = Integer(12); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A = Integer(0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A); _sage_const_0x6666666666666666666666666666666666666666666666666666666666666658 = Integer(0x6666666666666666666666666666666666666666666666666666666666666658); _sage_const_252 = Integer(252); _sage_const_27742317777372353535851937790883648493 = Integer(27742317777372353535851937790883648493); _sage_const_32 = Integer(32); _sage_const_31 = Integer(31); _sage_const_0x80 = Integer(0x80); _sage_const_7 = Integer(7); _sage_const_0x7F = Integer(0x7F); _sage_const_255 = Integer(255); _sage_const_19 = Integer(19); _sage_const_121665 = Integer(121665); _sage_const_121666 = Integer(121666); _sage_const_8 = Integer(8); _sage_const_3 = Integer(3)
from utils import (
    Edwards_Neutral_Element_Affine,
    Edwards_Neutral_Element_Projective,
    AffinePoint,
    ProjectivePoint,
    affine_to_proj,
    proj_to_affine
)
import os
import hashlib
p = _sage_const_0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed 
K = GF(p)
a = K(_sage_const_0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec )
d = K(_sage_const_0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3 )
E = EllipticCurve(K, (K(-_sage_const_1 /_sage_const_48 ) * (a**_sage_const_2  + _sage_const_14 *a*d + d**_sage_const_2 ),K(_sage_const_1 /_sage_const_864 ) * (a + d) * (-a**_sage_const_2  + _sage_const_34 *a*d - d**_sage_const_2 )))
E.set_order(_sage_const_0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed  * _sage_const_0x08 )



def to_weierstrass(P: AffinePoint) -> AffinePoint:
	return AffinePoint((_sage_const_5 *a + a*P.y - _sage_const_5 *d*P.y - d)/(_sage_const_12  - _sage_const_12 *P.y), (a + a*P.y - d*P.y -d)/(_sage_const_4 *P.x - _sage_const_4 *P.x*P.y))

def to_twistededwards(P: AffinePoint) -> AffinePoint:
    u, v = P
    y = (_sage_const_5 *a - _sage_const_12 *u - d)/(-_sage_const_12 *u - a + _sage_const_5 *d)
    x = (a + a*y - d*y -d)/(_sage_const_4 *v - _sage_const_4 *v*y)
    return AffinePoint(x, y)



def edwards_addition(P1: ProjectivePoint, P2: ProjectivePoint) -> ProjectivePoint:
    # page 21
    X1, Y1, Z1 = P1
    X2, Y2, Z2 = P2

    A = Z1 * Z2
    B = A * A
    C = X1 * X2
    D = Y1 * Y2
    E = d * C * D
    F = B - E
    G = B + E

    X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    Y3 = A * G * (D - a * C) # a here
    Z3 = G * F

    return ProjectivePoint(X3, Y3, Z3)

Edwards_Neutral_Element_Projective = ProjectivePoint(K(_sage_const_0 ), K(_sage_const_1 ), K(_sage_const_1 ))

def edwards_scalar_multiplication(P: AffinePoint, scalar: int) -> AffinePoint:
    P_proj = affine_to_proj(P, K)
    Q = P_proj
    R = Edwards_Neutral_Element_Projective
    while scalar > _sage_const_0 :
        if scalar % _sage_const_2  == _sage_const_1 :
            R = edwards_addition(R, Q)
        Q = edwards_addition(Q, Q)
        scalar = scalar // _sage_const_2 

    return proj_to_affine(R) # er det ikke akavet at være i projective? måske vi burde lave pointen om til projective i funktionen og returnere 

Gx, Gy = K(_sage_const_0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A ), K(_sage_const_0x6666666666666666666666666666666666666666666666666666666666666658 )
B = AffinePoint(Gx, Gy)
l = _sage_const_2  ** _sage_const_252  + _sage_const_27742317777372353535851937790883648493   # B's group order

def generate_keypair():
    # Implemented accordingly to "High-speed high-security signatures"
    k = os.urandom(_sage_const_32 )
    b_least_significant_bits = hashlib.sha512(k).digest()[:_sage_const_32 ]
    s = int.from_bytes(b_least_significant_bits, 'little')

    A = edwards_scalar_multiplication(B, s)
    return A, k

def encode_point(P: AffinePoint):
    #Implemented according to https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.2
    x, y = P

    y_bytes = list(y.to_bytes('little'))
    if x.lift() & _sage_const_1 : 
        y_bytes[_sage_const_31 ] |= _sage_const_0x80 
    return bytes(y_bytes)

def decode_point(encoded_bytes):
    # Implemented according to https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3
    encoded = bytearray(encoded_bytes)
    x_0 = (encoded[_sage_const_31 ] >> _sage_const_7 ) & _sage_const_1 
    encoded[_sage_const_31 ] &= _sage_const_0x7F 
    y_int = int.from_bytes(encoded, 'little')

    p = _sage_const_2 **_sage_const_255  - _sage_const_19 
    if y_int >= p:
        raise ValueError("Decoding fails: y >= p")

    y = K(y_int)  
    
    u = (y ** _sage_const_2  - _sage_const_1 )
    d = -_sage_const_121665  * pow(_sage_const_121666 , -_sage_const_1 , p) 
    v = (d * y ** _sage_const_2  + _sage_const_1 )
    
    pow_result = pow(u * v ** _sage_const_7 , (p - _sage_const_5 ) // _sage_const_8 , p)
    x = (u * v ** _sage_const_3  * pow_result)
    
    v_x2 = (v * x ** _sage_const_2 )
    
    if v_x2 == u:
        pass
    elif v_x2 == (-u):
        x = (x * pow(_sage_const_2 , (p - _sage_const_1 ) // _sage_const_4 , p))
    else:
        raise ValueError("Decoding fails: no square root exists")
    
    if x == _sage_const_0  and x_0 == _sage_const_1 :
        raise ValueError("Decoding fails: x = 0 and x_0 = 1")
    
    if x.lift() % _sage_const_2  != x_0:
        x = p - x
    
    return AffinePoint(x, y)


def sign_message(message, k):
    # Implemented accordingly to "High-speed high-security signatures"
    secret_key_hash = hashlib.sha512(k).digest()
    b_least_significant_bits = secret_key_hash[:_sage_const_32 ]
    
    a = int.from_bytes(b_least_significant_bits, 'little') % l
    
    A = edwards_scalar_multiplication(B, a)
    A_encoded = encode_point(A)
    message_prefix = secret_key_hash[_sage_const_32 :]
    r = hashlib.sha512(message_prefix + message).digest()
    r_int = int.from_bytes(r, 'little') % l

    R = edwards_scalar_multiplication(B, r_int)
    R_encoded = encode_point(R)

    S = (r_int + (int.from_bytes(hashlib.sha512(R_encoded + A_encoded + message).digest(),'little')*a)) % l
    return int.from_bytes(R_encoded, 'little'), S

def verify_message(message, A, R_encoded_int, S):
    # Implemented accordingly to "High-speed high-security signatures"
    R_encoded = int.to_bytes(R_encoded_int, _sage_const_32 , 'little')
    R = decode_point(R_encoded)
    lhs = edwards_scalar_multiplication(edwards_scalar_multiplication(B,S), _sage_const_8 )
    HAM = int.from_bytes(hashlib.sha512(R_encoded + encode_point(A) + message).digest(), 'little') % l
    rhs_1 = edwards_scalar_multiplication(
        edwards_scalar_multiplication(
            A, HAM
        ), _sage_const_8 )
    rhs_2 = edwards_scalar_multiplication(R,_sage_const_8 ) 
    rhs_1 = affine_to_proj(rhs_1, K)
    rhs_2 = affine_to_proj(rhs_2, K)
    rhs = edwards_addition(rhs_1, rhs_2)
    rhs = proj_to_affine(rhs)
    print(rhs)
    print(lhs)
    if rhs != lhs:
        raise ValueError("Signature not valid")
    
    return "Signature accepted"

