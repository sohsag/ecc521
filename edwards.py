

# This file was *autogenerated* from the file edwards.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff = Integer(0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); _sage_const_0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa4331 = Integer(0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa4331); _sage_const_1 = Integer(1); _sage_const_48 = Integer(48); _sage_const_14 = Integer(14); _sage_const_2 = Integer(2); _sage_const_864 = Integer(864); _sage_const_34 = Integer(34); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_12 = Integer(12); _sage_const_4 = Integer(4)
from sage.all import *
from collections import namedtuple

AffinePoint = namedtuple('AffinePoint', ['x', 'y'])
ProjectivePoint = namedtuple('ProjectivePoint', ['X', 'Y', 'Z'])

# constants from https://neuromancer.sk/std/other/E-521
p = _sage_const_0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 
K = GF(p)
# d is used to construct edwards curve.
d = K(
    _sage_const_0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa4331 )
# This is a weierstrass curve, that is birationally equivalent to the edwards curve with the d value above.
E = EllipticCurve(K, (
    K(-_sage_const_1  / _sage_const_48 ) * (_sage_const_1  + _sage_const_14  * d + d ** _sage_const_2 ),  # a
    K(_sage_const_1  / _sage_const_864 ) * (_sage_const_1  + d) * (-_sage_const_1  + _sage_const_34  * d - d ** _sage_const_2 )  # b
))

Edwards_Neutral_Element_Affine = AffinePoint(_sage_const_0 , _sage_const_1 )
Edwards_Neutral_Element_Projective = ProjectivePoint(_sage_const_0 , _sage_const_1 , _sage_const_1 )

# conversions found https://neuromancer.sk/std/other/Ed25519
def to_weierstrass(P: AffinePoint) -> AffinePoint:
    x = (_sage_const_5  + P.y - _sage_const_5  * d * P.y - d) / (_sage_const_12  - _sage_const_12  * P.y)
    y = (_sage_const_1  + P.y - d * P.y - d) / (_sage_const_4  * P.x - _sage_const_4  * P.x * P.y)
    return AffinePoint(x, y)


def to_edwards(P: AffinePoint) -> AffinePoint:
    u, v = P
    y = (_sage_const_5  - _sage_const_12  * u - d) / (-_sage_const_12  * u - _sage_const_1  + _sage_const_5  * d)
    x = (_sage_const_1  + y - d * y - d) / (_sage_const_4  * v - _sage_const_4  * v * y)
    return AffinePoint(x, y)


def affine_to_proj(P: AffinePoint) -> ProjectivePoint:
    return ProjectivePoint(P.x, P.y, K(_sage_const_1 ))


def proj_to_affine(P: ProjectivePoint) -> AffinePoint:
    return AffinePoint(P.X / P.Z, P.Y / P.Z)


def edwards_addition(P1: ProjectivePoint, P2: ProjectivePoint) -> ProjectivePoint:
    # page 21
    X1, Y1, Z1 = P1
    X2, Y2, Z2 = P2

    A = Z1 * Z2
    B = A * A
    C = X1 * X2
    D = Y1 * Y2
    E = d * C * D
    F = B - E
    G = B + E

    X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    Y3 = A * G * (D - C)
    Z3 = G * F

    return ProjectivePoint(X3, Y3, Z3)


def edwards_doubling(P: ProjectivePoint) -> ProjectivePoint:
    X, Y, Z = P
    B = (X + Y) ** _sage_const_2 
    C = X ** _sage_const_2 
    D = Y ** _sage_const_2 
    E = C + D
    H = Z ** _sage_const_2 
    J = E - _sage_const_2  * H

    X3 = (B - E) * J  # <-- book is wrong here. book X3 = B - E
    Y3 = E * (C - D)
    Z3 = E * J

    return ProjectivePoint(X3, Y3, Z3)


def edwards_scalar_multiplication(P: ProjectivePoint, scalar: int) -> ProjectivePoint:
    Q = P
    R = ProjectivePoint(_sage_const_0 , _sage_const_1 , _sage_const_1 )
    while scalar > _sage_const_0 :
        if scalar % _sage_const_2  == _sage_const_1 :
            R = edwards_addition(R, Q)
        Q = edwards_doubling(Q)
        scalar = scalar // _sage_const_2 

    return R


def edwards_inversion(P: ProjectivePoint) -> ProjectivePoint:
    X, Y, Z = P
    return ProjectivePoint(-X, Y, Z)

